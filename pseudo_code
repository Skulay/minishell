deja comprendre en quoi consiste le projet

1. comprendre toute les commande qu'il est possible d'utiliser
	-prendre des notes sur les commande suseptible d'etre le plus utiliser
	-reflechir a la facon d'organiser le code et finir de remplir ce fichier
	-Bonus ou pas ??
	-si bonus y reflechir des le debut

2. creer un programe qui display un prompt et attend qu'on tape des commandes
	-un programe qui tourne avec une boucle et execute les commande
	-

3. pour le lancer faudras faire "./minishell"
	-donc premier lancement on gere 0 argument
	-

4. tout se passe apres avec un get next line qui liras la commande taper


-----------------------------------------------------------------------

2 point clef -> la partie execution et la partie parsing

possibilliter de split le minishell sur ces deux partie

-----------------------------------------------------------------------
						PARTIE EXECUTION

grosso modo c'est un giga pipex qui tourne en boucle et execute les commandes



-----------------------------------------------------------------------
						PARTIE PARSING

1. gerer tout les token ( / | $ > < ect)

2.

-----------------------------------------------------------------------
						IDEE POUR LE RENDRE PLUS SYMPA

1. gerer le prompt pour afficher le NAME (dans env)
2. suivi du PATH ou on se situe
3. couleur en fonction de la reussite de la cmd
4. ???

-----------------------------------------------------------------------
						CE QUI EST DEJA GERER

ctrl+D est deja gerer avec readline()

l'historique avec les fleche deja gerer avec add_history(line) -> ne pas oublier de clear l'historique a la fin clear_history()

----------------------------------------------------------------------
readline : lit une ligne depuis l’entrée utilisateur avec édition et historique.
rl_clear_history : efface l’historique des lignes de readline.
rl_on_new_line : indique à readline qu’on passe sur une nouvelle ligne.
rl_replace_line : remplace le contenu courant de la ligne éditée par readline.
rl_redisplay : réaffiche la ligne courante (mise à jour de l’affichage).
add_history : ajoute une ligne à l’historique de readline.
printf : affiche du texte formaté sur la sortie standard.
malloc : alloue un bloc de mémoire sur le tas.
free : libère un bloc mémoire alloué par malloc.
write : écrit des octets sur un descripteur de fichier.
access : teste l’existence et/ou les droits d’accès d’un fichier.
open : ouvre (ou crée) un fichier et renvoie un descripteur.
read : lit des octets depuis un descripteur de fichier.
close : ferme un descripteur de fichier.
fork : crée un nouveau processus en dupliquant le processus courant.
wait : attend la fin d’un processus enfant.
waitpid : attend la fin d’un enfant spécifique (ou selon options).
wait3 : attend un enfant et récupère des infos d’usage (resource usage).
wait4 : comme wait3 mais avec plus de contrôle (pid/options).
signal : installe un gestionnaire simple pour un signal.
sigaction : installe un gestionnaire de signal avec options avancées.
sigemptyset : initialise un ensemble de signaux vide.
sigaddset : ajoute un signal à un ensemble de signaux.
kill : envoie un signal à un processus (ou groupe).
exit : termine le processus avec un code de retour.
getcwd : récupère le chemin absolu du répertoire courant.
chdir : change le répertoire courant.
stat : récupère les métadonnées d’un fichier (en suivant les liens).
lstat : récupère les métadonnées d’un lien symbolique (sans le suivre).
fstat : récupère les métadonnées via un descripteur de fichier.
unlink : supprime un nom de fichier (déréférence l’entrée).
execve : remplace le processus courant par un nouveau programme.
dup : duplique un descripteur de fichier (nouveau fd).
dup2 : duplique un fd vers un fd donné (écrase si nécessaire).
pipe : crée un tube anonyme (paire de fd lecture/écriture).
opendir : ouvre un répertoire pour lecture (DIR*).
readdir : lit l’entrée suivante d’un répertoire ouvert.
closedir : ferme un répertoire ouvert (DIR*).
strerror : renvoie une chaîne décrivant un code d’erreur errno.
perror : affiche un message + la description de errno sur stderr.
isatty : teste si un fd correspond à un terminal.
ttyname : renvoie le chemin du terminal associé à un fd.
ttyslot : renvoie l’index de l’entrée terminal dans la base utmp.
ioctl : exécute une commande de contrôle spécifique sur un fd/périphérique.
getenv : lit la valeur d’une variable d’environnement.
tcsetattr : applique des paramètres de terminal (termios) à un fd.
tcgetattr : lit les paramètres de terminal (termios) d’un fd.
tgetent : charge la description termcap d’un type de terminal.
tgetflag : lit une capacité booléenne termcap.
tgetnum : lit une capacité numérique termcap.
tgetstr : lit une capacité chaîne termcap.
tgoto : calcule une séquence de déplacement du curseur (termcap).
tputs : affiche une chaîne termcap en gérant le padding/délais.

